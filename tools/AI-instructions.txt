generate a detailed to do list to use the following approach to handle a request to add or change functionality:

when adding or editing files for this functionality keep track of the files added or edited over the different commits, for the reviews at the end.  
when creating a commit message, always prefix it consistent with previous messages, then add the reason (one line) to make the change base don the instructions given and this workflow, you can add a small summary of the changes made, but keep it small we can read the diffs for the details.  

first describe the requirements in terms of examples (try to maintain a GWT style)
- ask for confirmation before continuing

  then take the simplest example and write a test for it in GWT format
    Prove that the code doesn't support this behaviour yet by running the test and see it fail for the expected reason
    then make the test pass
    when green: ask for confirmation by preparing a commit with a message describing the use-case added

**CRITICAL TDD STEP-BY-STEP PROCESS:**
1. Write test first - it should fail for functional reasons (missing behavior)
2. Add ONLY the minimal structure needed (function signatures, imports) - test still fails
3. Implement ONLY the behavior needed to make THIS test pass - test now passes
4. Commit this single use-case
5. Move to next simplest example and repeat
  then continue defining the next simplest example, gradually building all use-cases for the functionality
  
  when the feature is complete 
    review the tests, 
    detect test coverage duplication, 
    and suggest steps to reduce the duplication favoring API tests, 
      only keeping the lower level tests to reduce execution speed and test complexity
    -> ask for confirmation by preparing a commit with a message message the functionality added

  IMPORTANT: Update help commands and documentation
    - Add new commands to src/cli/commands.py show_list() function
    - Add short aliases to the help output
    - Update command reference documentation
    - Test the actual command line interface to verify help output

  IMPORTANT: Version and release the feature
    - Bump version using python tools/set-version.py (minor for features, patch for fixes)
    - Stage and commit these 3 files together: scripts/version.json, README.md, .code_hash
    - Use commit message: "chore: bump version to X.Y.Z for [feature name]"
    - Push changes to remote repository
    - Create GitHub release with feature description

  BUG: Fix release script to commit linter auto-fixes
    - The release script runs markdown linting and auto-fixes files
    - These auto-fixed files are not included in the release commit
    - Need to modify scripts/release.ps1 to commit any files modified by linter
    - This prevents leaving uncommitted changes after release

  then review the code
    extract large code blocks into intent-revealing classes and functions
  then review the files that were added or edited in this process 
    and break up large files into smaller files with a single purpose 
  -> ask for confirmation by preparing a commit with a message message the functionality added

## Implementation Details:

**File Tracking:**
- Keep a list in memory of files added/edited
- Also create temp file in project (e.g., `.temp/implementation-files.txt`) that's git-ignored

**Test Failure Verification:**
- Tests must fail for functional reasons (missing behavior), not technical reasons (imports, syntax, etc.)
- Examples of functional failures: NotImplementedError, missing function, wrong behavior
- Examples of technical failures: ImportError, SyntaxError, AttributeError on imports

**Commit Message Prefixes:**
- Use: feat, fix, cleanup, chore, refactor
- Keep consistent with recent commit history

**Test Coverage Duplication Detection:**
- Detect if more than 1 test verifies the same functional use-case or part of it
- Prefer tests that test the use-case as a whole
- Keep lower level tests only if:
  - Too many meaningful variations that would obfuscate API test intent
  - API test setup/validation becomes too complex
  - In that case, review the design

**Code Extraction Criteria:**
- Large functions: >10 lines
- Large classes: >50 lines
- Use functional domain language (not technical IT language)

**File Splitting Criteria:**
- Large files: >100 lines
- Split into files with single purpose

**MINIMAL IMPLEMENTATION RULES:**
- NEVER implement more than needed for the current test to pass
- NEVER add CLI integration until you have a working function
- NEVER add multiple features in one step
- ALWAYS implement behavior only after structure is in place
- ALWAYS verify test fails for functional reasons before implementing

